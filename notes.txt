------------------------------------------------------------------------------------------- Section 1 ---------------------------------------------------------------------------------------

-- Spring Boot Overview

• Spring in Nutshell
Very popular framework for building Java applications
Provides a large number of helper classes and annotations
The Problem is building a traditional Spring application is really HARD!!!

• Spring Boot Solution
Make it easier to get started with Spring development
Minimize the amount of manual configuration
Perform auto-configuration based on props files and JAR classpath
Help to resolve dependency conflicts (Maven or Gradle)
Provide an embedded HTTP server so you can get started quickly
Tomcat, Jetty, Undertow, ...

• Spring Boot and Spring
Spring Boot uses Spring behind the scenes
Spring Boot simply makes it easier to use Spring


-- Spring Initializer Demo

• Spring Initializer 
Quickly create a starter Spring project by going to http://start.spring.io
Select your dependencies
Creates a Maven/Gradle project
Import the project into your IDE
Eclipse, IntelliJ, NetBeans etc ...

• Quick word on Maven
When building your Java project, you may need additional JAR files
For example: Spring, Hibernate, Commons Logging, JSON etc...
One approach is to download the JAR files from each project web site
Manually add the JAR files to your build path / classpath

• Maven Solution
Tell Maven, the projects you are working with (dependencies) like Spring, Hibernate etc ....
Maven will go out and download the JAR files for those projects for you
And Maven will make those JAR files available during compile/run
Think of Maven as your friendly helper / personal shopper

• Development Process
1. Configure our project at Spring Initializr website http://start.spring.io
2. Download the zip file
3. Unzip the file
4. Import the project into our IDE
5. Give sometime to IDE to download all Maven Dependencies
6. Run the main java file
7. Simple go to localhost:8080 which is intialized and started by Tomcat.


-- Create a REST Controller

• Example for how to create a simple REST Controller
  Project: 01-spring-boot-demo

-- Spring Framework Overview - Part 1

• Goals of Spring
Lightweight development with Java POJOs (Plain-Old-Java-Objects)
Dependency injection to promote loose coupling
Minimize boilerplate Java code


-- What is Maven?

Maven is a Project Management tool. Most popular use of Maven is for build management and dependencies. When building your Java project, 
you may need additional JAR files for example: Spring, Hibernate, Commons Logging, JSON etc. One approach is to download the JAR files from each project web site.
Manually add the JAR files to your build path / classpath. Another approch is tell Maven, the projects you are working with (dependencies) like Spring, Hibernate etc.
Maven will go out and download the JAR files for those projects for you. And Maven will make those JAR files available during compile/run. Think of Maven as your friendly 
helper / personal shopper. 

• Handling JAR Dependencies
When Maven retrieves a project dependency. It will also download supporting dependencies like Spring depends on commons-logging.
Maven will handle this for us automagically

• Building and Running
When you build and run your app ...
Maven will handle class / build path for you
Based on config file, Maven will add JAR files accordingly


-- Maven Project Structure

Normally when you join a new project
Each development team dreams up their own directory structure
Not ideal for new comers and not standardized
Maven solves this problem by providing a standard directory structure

• Standard Directory Structure
Directory			Description
src/mainijava			Your Java source code
src/main/resources		Properties / config files used by your app
src/main/webapp			JSP files and web config files other web assets (images, css, js, etc)
src/test			Unit testing code and properties
target				Destination directory for compiled code. Automatically created by Maven


-- Maven Key Concepts

• POM File - pom.xml
POM Stands for Project Object Model File
It is the configuration file for our project
It is always located in the root for our project
THe pom.xml file consist of three things: project meta data, dependencies and plug-ins.
project meta data: Project name, version and Output file type: JAR, WAR, ...
dependencies:      List of projects we depend on Spring, Hibernate, etc
plug ins:	   Additional custom tasks to run: generate JUnit test reports etc


• Project Coordinates
Project Coordinates uniquely identify a project
Similar to GPS coordinates for your house: latitude / longitude
Precise information for finding your house (city, street, house #)

Example:
<groupId>com.springboot.demo</groupId>
<artifactId>myFirstApp</artifactId>
<version>0.0.1-SNAPSHOT</version>


-- Exploring Spring Boot Project Files - Part 1

• Maven Standard Directory Structure
Directory			Description
src/mainijava			Your Java source code
src/main/resources		Properties / config files used by your app
src/test/java			Unit testing source code

• Maven Wrapper files
mvnw allows you to run a Maven project. There is no need to have Maven installed or present on your path. If correct version of Maven is NOT found on your computer
it automatically downloads correct version and runs Maven.
There are two files that are already provided: 
mvnw.cmd for MS Windows	to run commands like	-->	mvnw clean comiple test
mvnw.sh for Linux/Mac	to run commands like	-->	./mvnw clean comiple test

• Maven POM file
pom.xml includes info that you entered at Spring Initializr website. 
It includes: Spring Boot Starters (A collection of Maven dependencies)
             Spring Boot Maven plugin which is used to To package executable jar or war archive. And it can also easily run the app(./mvnw package) (-/mvnw spring-boot:run)

• Java Source Code
The Java Source Code includes:
Main Spring Boot application class
RestController that we created in an earlier video


-- Exploring Spring Boot Project Files - Part 2

• Application Properties
By default, Spring Boot will load properties from: application.properties.
The file 'application.properties' happens to be empty at the beginning.
We can add spring boot properties:	
server.port=8585
We can also add our own custom properties:  
coach.name=Mickey Mouse
team.name=The Mouse Crew

Now to make use of all those custom properties which we created into our 'application.properties', we can do with below code
@RestController
public class FunRestController {

 @Value ("${coach.name}")
 private String coachName;

 @value ("${team.name}")
 private String teamName;
 
 ...
} 

• Static Content
By default, Spring Boot will load static resources from "/static" directory
Examples of static resources are HTML files, CSS, JavaScript, images etc.


• Unit Tests
It includes Spring Boot unit test class where we can add unit tests to the file.


-- Spring Boot Starters

• What is Spring Boot Starters?
A curated list of Maven dependencies
A collection of dependencies grouped together
Tested and verified by the Spring Development team
Makes it much easier for the developer to get started with Spring
Reduces the amount of Maven configuration

Spring Boot provides 'spring-boot-started-web' which is a collection of dependencies.
It contain dependencies such as spring-web, spring-webmvc, hibernate-validator, json, tomcat etc.

There are 30 plus Spring Boot Starters from the Spring Development team.
Name				Description
spring-boot-starter-web 	Building web apps, includes validation, REST. Uses Tomcat as default embedded server
spring-boot-starter-securty	Adding spring security support
spring-boot-starter-data-jpa	Spring database support with JPA and Hibernate
...				...


-- Spring Boot Parents for Starters

Spring Boot provides a "Starter Parent"
This is a special starter that provides Maven defaults
<parent>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-parent</artifactId>
 <version>3.@.Q-RC1</version>
 <relativePath/> <!/-- lookup parent from repository -->
</parent>


• Benefits of the Spring Boot Starter Parent
Default Maven configuration: Java version, UTF-encoding etc
Dependency management
 Use version on parent only
 spring-boot-starter-* dependencies inherit version from parent
Default configuration of Spring Boot plugin


-- Spring Boot Dev Tools - Overview

Automatically restarts your application when code is updated
Simply add the dependency to your POM file
No need to write additional code :-)
For IntelliJ, need to set additional configurations.

When we add the dependency to our POM file. It will automatically restarts your application when code is updated
<dependency>
<groupId>org.springframework .boot</groupId>
<artifactId>spring-boot-devtools</artifactId>
</dependency> 

• Development Process
Steps:
1. Apply IntelliJ configurations
2. Edit pom.xml and add spring-boot-devtools
3. Add new REST endpoint to our app
4. Verify the app is automatically reloaded


-- Spring Boot Dev Tools - Coding
• Example for how to set devtools
  Project: 02-dev-tools-demo 


-- Spring Boot Actuator - Overview

Exposes endpoints to monitor and manage your application
You easily get DevOps functionality out-of-the-box
Simply add the dependency to your POM file
REST endpoints are automatically added to your application
No need to write additional code!
You get new REST endpoints for FREE!

Once we add the dependency to your POM file. It enables Spring Boot Actuator.
<dependency>
    <groupId>org.springframework .boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Automatically exposes endpoints for metrics out-of-the-box
Endpoints are prefixed with: /actuator
Name 		Description
/health 	Health information about your application

• Health Point
/health checks the status of your application
Normally used by monitoring apps to see if your app is up or down

• Info Point
By default, It is empty
The /info endpoint can provide information about your application
To expose /info: we need to make below changes
File: src/main/resources/application.properties
management.endpoints.web.exposure.include=health,info
management.info.env.enabled=true

we also need to update application.properties with your app info
File: src/main/resources/application.properties
info.app.name=My Super Cool App
info.app.description=A crazy and fun app, yoohoo!
info.app.version=1.0.0

Properties starting with "info." will be used by /info

• Other Spring Boot Actuator Endpoints
There are 10+ Spring Boot Actuator endpoints:
Name 			Description
/auditevents 		Audit events for your application
/beans 			List of all beans registered in the Spring application context
/mappings 		List of all @RequestMapping paths


• How to make use of all Spring Boot Actuator Endpoints
By default, only /health is exposed
To expose all actuator endpoints over HTTP
File: src/main/resources/application.properties
# Use wildcard "*" to expose all endpoints
# Can also expose individual endpoints with a comma-delimited list
management.endpoints.web.exposure.include=*		

Above one line of code exposes all endpoints


• Get a list of beans
Access http://localhost:8080/actuator/beans

• Development Process
Steps:
1. Edit pom.xml and add spring-boot-starter-acuator
2. View actuator endpoints for: /health
3. Edit application .properties to customize /info


-- Spring Boot Actuator - Accessing Endpoints - Part 1
• Example for how to set actuator
  Project: 03-actuator-demo


-- Spring Boot Actuator - Securing Endpoints - Overview

• What about Security?
We may NOT want to expose all of this information
Add Spring Security to project and endpoints are secured. Below code enables Spring Security
<dependency>
    <groupid>org.springframework .boot</groupId>
    <artifactId>spring-boot-starter-security</artifactid>
</dependency>

• Secured Endpoints
Once we put above dependency, and than if we access: /actuator/beans
Spring Security will prompt for login where the 
user name: user 
Password: it will automatically generate into our terminal

There is also one more way to set user name and password:
We can override default user name and generated password
File: src/main/resources/application.properties
spring.security.user.name=scott
spring.security.user.password=tiger

• Customizing Spring Security
We can customize Spring Security for Spring Boot Actuator
Use a database for roles, encrypted passwords etc ...

• Exclude endpoints 
We can also exclude endpoints.
To exclude /health and /info
File: src/main/resources/application.properties
# Exclude individual endpoints with a comma-delimited list
management.endpoints.web.exposure.exclude=health, info

• Development Process
1. Edit pom.xml and add spring-boot-starter-security
2. Verify security on actuator endpoints for: /beans etc
3. Disable endpoints for /health and /info


-- Spring Boot Actuator - Securing Endpoints - Coding
• Example for how to secure actuator endpoints
  Project: 04-actuator-security-demo


-- Run Spring Boot apps from the Command Line - Overview

• Running from the Command-Line
When running from the command-line. There is no need to have IDE open/running
Since we using Spring Boot, the server is embedded in our JAR file. There is no need to have separate server installed / running
Because Spring Boot apps are self-contained.

Two options for running the app from the command line:
Option 1: Use 				-->	java -jar appName.jar(if you already have the jar file of your application)
Option 2: Use Spring Boot Maven plugin	-->	1. mvnw package(this will create a jar file of our application)		2. mvnw spring-boot: run
Remember the JAR file gets created in the 'target' subdirectory.

•  Development Process
1. Exit the IDE
2. Package the app using mvnw package
3. Run app using java -jar
4. Run app using Spring Boot Maven plugin, mvnw spring-boot: run


-- Run Spring Boot apps from the Command Line - Demo
For This Example, I simply did below steps:
1. Open my Bash Terminal into the application folder directly which is '05-command-line-demo'
2. On the Git Bash Terminal, I run: ./mvnw package
3. Now the above command creates a JAR file of our application into the 'target' folder.
4. So I run: cd target to go inside the target folder.
5. Now to run our application, I run the command: ava -jar  myFirstApp-0.0.1-SNAPSHOT.jar(which is the actual name of our application)
 

-- Injecting Custom Application Properties - Overview

• Application Properties File
By default, Spring Boot reads information from a standard properties file which is located at: src/main/resources/application. properties
We can define ANY custom properties in this Standard Spring Boot file.
Once we write custom properties, Spring Boot app can access those properties using @Value.
And there is no additional coding or configuration required.

• Development Process
Steps:
1. Define custom properties in application.properties
We can give ANY custom property names and as many as we want.
File: src/main/resources/application.properties:
# Define custom properties
coach.name=Mickey Mouse
team.name=The Mouse Club

2. Inject properties into Spring Boot application using @Value
@RestController
public class FunRestController {

// inject properties for: coach.name and team.name
@Value ("${coach.name}")
private String coachName;

@Value ("${team.name}")
private String teamName;

...
}

-- Injecting Custom Application Properties - Coding
• Example for inject custom application properties into a java file
  Project: 06-properties-demo


-- Configuring the Spring Boot Server - Overview
Spring Boot can be configured in the application. properties file
Server port, context path, actuator, security etc.
Spring Boot has over 1000 properties.
The properties are roughly grouped into the following categories:
Core, Web, Security, Data, Actuator, Integration, DevTools, Testing


• Core Properties
File: src/main/resources/application.properties
# Log levels severity mapping
# Set logging levels based on package names
logging.level.org.springframework=DEBUG
logging.level.org.hibernate=TRACE
logging.level.com. luv2code=INFO
# Log file name
logging.file=my-crazy-stuff.log

• Web Properties
File: src/main/resources/application.properties
# HTTP server port, The default server local host is 8080
server.port=7070
# Context path of the application, The default context path is '/'
server.servlet.context-path=/my-silly-app
# Default HTTP session time out, The default session time out is 30min.
server.servlet.session.timeout=15m

• Actuator Properties
File: src/main/resources/application.properties
# Endpoints to include by name or wildcard
management.endpoints.web.exposure.include=*
# Endpoints to exclude by name or wildcard
management.endpoints.web.exposure.exclude=beans,mapping
# Base path for actuator endpoints
Management.endpoints.web.base-path=/actuator

• Security Properties
File: src/main/resources/application.properties
# Change default user name
spring.security.user.name=admin
# Chaneg password for default user
spring.security.user.password=topsecret

• Data Properties
File: srcimain/resources/application. properties
# JDBC URL of the database
spring.datasource.url=jdbc:mysql: //localhost :3306/ecommerce
# Login username of the database
spring.datasource.username=scott
# Login password of the database
spring.datasource.password=tiger

• Development Process
Steps:
1. Configure the server port
2. Configure the application context path



------------------------------------------------------------------------------------------- Section 2 ---------------------------------------------------------------------------------------

-- What is Inversion of Control?
Inversion of Control (IoC) is a design pattern in object-oriented programming where the control of object creation 
and management is inverted from the application code to an external framework.

• Spring Container
Primary functions: 
 Create and manage objects (Inversion of Control)
 Inject object dependencies (Dependency Injection)

• Configuring Spring Container: 3 ways
XML configuration file (legacy)
Java Annotations (modern) 
Java Source Code (modern)


-- Defining Dependency Injection - Overview - Part 1

• Dependency Injection
The dependency inversion principle.
The client delegates to another object the responsibility of providing its dependencies.

• Injection Types
There are multiple types of injection with Spring
The two recommended types of injection: 
Constructor Injection
 Use this when you have required dependencies
 Generally recommended by the spring.io development team as first choice
Setter Injection
 Use this when you have optional dependencies
 If dependency is not provided, your app can provide reasonable default logic

• What is Spring AutoWiring
For dependency injection, Spring can use autowiring
Spring will look for a class that matches by type: class or interface
Spring will inject it automatically ... hence it is autowired

• @Component annotation
@Component marks the class as a Spring Bean
A Spring Bean is just a regular Java class that is managed by Spring
@Component also makes the bean available for dependency injection


-- Defining Dependency Injection - Overview - Part 1
• Example Application
Web Browser	---- /dailyWorkout ---->		DemoController		---- getDailyWorkout() ---->		Coach
Web Browser	---- Practice Fast Bowling ---->	DemoController		---- "Practice Fast Bowling" ---->	Coach

• Development Process - Constructor Injection
1. Define the dependency interface and class
2. Create Demo REST Controller
3. Create a constructor in your class for injections
4. Add @GetMapping for /dailyworkout


-- Constructor Injection - Coding - Part 1
Generating A Maven Project through https://start.spring.io/


-- Constructor Injection - Coding - Part 2
• Example for how to use constructor injection 
  Project: 01-constructor-injection


--  Constructor Injection - Behind the Scenes

• How Spring Process our application
// All bellow code is happening behind the scenes:
Coach theCoach = new CricketCoach();	
DemoController demoController = new DemoController(theCoach); 		<-- Constructor Injection


--  Component Scanning - Overview

• Scanning for Component Classes
Spring will scan your Java classes for special annotations
 @Component, etc...
It will automatically register the beans in the Spring container
In the project: 01-constructor-injection, 
we have a Main Spring Boot Class: SpringcoredemoApplicaiton.java which is is created by Spring Initializer: https://start.spring.io/
Now this file imports: org.springframework.boot.autoconfigure.SpringBootApplication
because of which we were able to put the annotation: @SpringBootApplication
Now this annotation enables: Auto configuration, Component scanning, Additional configuration
Behind the Scenes, The @SpringBootApplication composed of @EnableAutoConfiguration, @ComponentScan and @Configuration annotations.

• Annotations
@SpringBootApplication is composed of the following annotations:

Annotation 			Description
@EnableAutoConfiguration 	Enables Spring Boot's auto-configuration support
@ComponentScan			Enables component scanning of current package. Also recursively scans sub-packages
@Configuration			Able to register extra beans with @Bean or import other configuration classes

• About SpringApplication.run
Here the ' SpringApplication.run ' bootstraps our spring boot application.
And in ' SpringApplication.run(SpringcoredemoApplication.class, args); ', we have to write the actual name of our class to
give a reference.
Behind the Scenes, This both above lines will create the application context, registers all beans and starts the embedded serve.

• More on Component Scanning
By default, Spring Boot starts component scanning
 From same package as your main Spring Boot application
 Also scans sub-packages recursively
This implicitly defines a base search package
 Allows you to leverage default component scanning
 No need to explicitly reference the base package name

• Explicitly list base packages to scan
@springBootApplication(
scanBasePackages={"com.practice.springcoredemo",
                  "com.practice.util",
                  “org.acme.cart",
                  "edu.cmu.srs"})
public class SpringcoredemoApplication {
    ...	
}


-- Component Scanning - Coding - Part 1
-- Component Scanning - Coding - Part 2
• Example for how to list baseScanPackages in Main Application and let spring boot component scan outsider packages
  Project: 02-component-scanning


-- Setter Injection - Overview

• Autowiring Example
First we will inject a Coach implementation. Than spring will scan for @Components and finds if there is any class that implements the Coach interface.
If yes there is one, it will inject it. For example: CricketCoach.

• Injection Types - Which one to use?
Constructor Injection
 Use this when you have required dependencies
 Generally recommended by the spring.io development team as first choice
Setter Injection
 Use this when you have optional dependencies
 If dependency is not provided, your app can provide reasonable default logic

• Development Process - Setter Injection
1. Create setter method(s) in your class for injections
2. Configure the dependency injection with @Autowired Annotation

• Example for how to use setter injection
  Project: 03-setter-injection


-- Field Injection

• Spring Injection Types
Recommended by the spring.io development team
 Constructor Injection: required dependencies
 Setter Injection: optional dependencies
Not recommended by the spring.io development team
Field Injection

• Why Field Injection is no longer in use?
In the early days, field injection was popular on Spring projects
 In recent years, it has fallen out of favor
In general, it makes the code harder to unit test
As a result, the spring.io team does not recommend field injection
 However, you will still see it being used on legacy projects

• How it works?
Field Injection is the idea of injecting in dependencies by setting the values on your class directly, even on private fields
and this is accomplished by Java Reflection.

Steps:
1. Configure the dependency injection with Autowired Annotation
File: DemoController.java
import org.springframework.beans.factory.annotation.Autowired;
@RestController
public class DemoController {
    @Autowired
    private Coach myCoach; 		// we have autowired the field here so that is why it is Field injection
    // no need for constructors or setters

   @GetMapping(" /dailyworkout")
   public String getDailyWorkout() {
       return myCoach.getDailyWorkout();
   } 
}


-- Qualifiers - Overview

• Autowiring Example
First we will inject a Coach implementation. Than spring will scan for @Components and finds if there is any class that implements the Coach interface.
If yes, but this time there are multiple of them, So spring will make use of Qualifiers to find one class that we wanted it to get injected.

• How it Works?
In our project, we have an interface 'Coach' and only one class 'CricketCoach' that implements 'Coach'. So it easy straight forward for spring to inject 
dependency if there is only one class that is implementing 'Coach'. 
Now consider that we have multiple classes that is implementing 'Coach' interface, Now how spring will know which class to choose.

If we have classes such as 'CricketCoach', 'BaseballCoach', 'TrackCoach' and 'TenisCoach', The Spring will show us below error when we run it:
 Parameter 0 of constructor in com.luv2code.springcoredemo.rest.DemoController
 required a single bean, but 4 were found:
 baseballCoach
 cricketCoach
 tennisCoach
 trackCoach

Now the solution here is to make use of ' @Qualifier("className") ' in the autowired constructor or setter function.
// File: DemoController.java (Constructor Example)
@Autowired
public DemoController(@Qualifier("cricketCoach") Coach theCoach) {// here we are telling spring tha make use of 'cricketCoach' class as the injection. While implementing 'Coach' interface. 
myCoach = theCoach;
}

// File: DemoController.java (Setter Example)
@Autowired
public void setMyCoach(@Qualifier("cricketCoach") Coach theCoach) {// here we are telling spring tha make use of 'cricketCoach' class as the injection. While implementing 'Coach' interface. 
myCoach = theCoach;
}


-- Qualifiers - Coding - Part 1
-- Qualifiers - Coding - Part 2

• Example for how to use Qualifier Annotaion
  Project: 04-qualifiers


-- Primary - Overview
 
• Resolving issue with Multiple Coach implementations
In the case of multiple Coach implementations. We resolved it using @Qualifier that is by specifing a coach by name
However there is also an Alternate solution.

• How it works?
Instead of putting the 'Qualifier' Annotation and specifing which class should be used.
We can just put the 'Primary' Annotation right above the Class which we wanted to be get used.
Example:
// File: TrackCoach.java
import org.springframework.context .annotation.Primary;
import org.springframework.stereotype.Component;
@Component
@Primary						// with this annotation, the spring will know that it has to use this class as an injection.
public class TrackCoach implements Coach {
    @override
    public String getDailyWorkout() {
    return "Run a hard 5k!";
    }
}

• If 'Primary' Annotation used more than once
The Primary Annotation can only be used once in case of Multiple Impletation.
If we try to mark multiple classes with Primary Annotation, we will get below error:
Unsatisfied dependency expressed through constructor parameter 0:
No qualifying bean of type 'com.luv2code.springcoredemo.common.Coach' available:
more than one ‘primary' bean found among candidates:
[baseballCoach, cricketCoach, tennisCoach, trackCoach]

• Mixing @Primary and @Qualifier
Firstly we can use both annotations at same time. But you might have to be careful which to use when.
Secondly, @Qualifier has higher priority that is if we used @Qualifier for 'CricketCoach' and @Primary for 'TrackCoach', Than Spring will go and use 'CricketCoach'.

• Which one: @Primary or @Qualifier?
@Primary leaves it up to the implementation classes
 Could have the issue of multiple @Primary classes leading to an error
@Qualifier allows to you be very specific on which bean you want
In general, I recommend using @Qualifier
 It is more specific.
 It has higher priority.


-- Primary - Coding
• Example for how to use Primary Annotaion
  Project: 05-primary


-- Lazy Initialization - Overview

• Initialization
By default, when our application starts, all beans are initialized so it will scan for all components such as @Component and those components will instialized. 
So spring will create an instance of each and make them available.

Now to see that all beans have been initialized on the start of our application, we can put a println statement which prints each class's name:
// File: CricketCoach.java
public CricketCoach() {
    System.out.println("In constructor: " + getClass().getSimpleName());
}

// File: BaseballCoach.java
public BaseballCoach() {
    System.out.println("In constructor: " + getClass().getSimpleName());
}

// File: TennisCoach.java
public TennisCoach() {
    System.out.println("In constructor: " + getClass().getSimpleName());
}

// File: TrackCoach.java
public TrackCoach() {
    System.out.println("In constructor: " + getClass().getSimpleName());
} 

Now once we run the application, all the beans that is our classes which spring converts them into beans once we put the '@Component' will get initialized 
and the terminal will show below lines:
In constructor: BaseballCoach
In constructor: CricketCoach
In constructor: TennisCoach
In constructor: TrackCoach

Now there is usually not need of all beans to get intialized at time of application start.
Now to resolve that, we can make use of 'Lazy Initialization' Annotation.

• Lazy Initialization
Instead of creating all beans up front, we can specify lazy initialization
A bean will only be initialized in the following cases:
 It is needed for dependency injection
 Or itis explicitly requested
Add the @Lazy annotation to a given class
Example:
// File: TrackCoach
import org.springframework.context annotation.Lazy;
import org.springframework.stereotype.Component;
@Component
@Lazy						// this will implement Lazy Initialization to this class.
public class TrackCoach implements Coach {
    public TrackCoach() {
        System.out.println("In constructor: " + getClass().getSimpleName());
    }
}


• Lazy Iniitialization - Global configuration
We can also use this Annotation on all our beans at one time which is with the help of 'application.properties' file.
File: application.properities
spring.main.lazy-initialization=true

Now with above line of declaration, All beans are lazy, no beans will get created untill needed, including our DemoController.
If we consider our Coach project, So once we access our REST endpoint of '/dailyworkout', then spring will determine the dependencies
for the DemoController. And for the dependency resolution, spring will create instance of 'CricketCoach' first then create instance
of 'DemoController' and injects the 'CricketCoach'.
 
• Advantages of using Lazy Initialization
Only create objects as needed
May help with faster startup time if you have large number of components

• Disadvantages
If you have web related components like @RestController, not created until requested
May not discover configuration issues until too late
Need to make sure you have enough memory for all beans once created


-- Lazy Initialization - Coding - Part 1
-- Lazy Initialization - Coding - Part 2
• Example for how to use Lazy Initialization Annotaion
  Project: 05-lazy-initialization


-- Bean Scopes - Overview
Scope refers to the lifecycle of a bean such as:  How long does the bean live? How many instances are created? How is the bean shared?

• Singleton Scope
Now the default scope is singleton.
Singleton means that by default, the Spring Container creates only one instance of the bean. It is catched in memory. And all dependency injections
for the bean will reference the same bean.(Single item that is created in memory and shared amongst different other items.) 
Singleton Example:
@RestController
public class DemoController {
    // Here we have created two references and both will point at the same instance.
    private Coach myCoach;			
    private Coach anotherCoach;

    @Autowired
    public DemoController(
                  @Qualifier("cricketCoach") Coach theCoach,			// first reference points at the 'CricketCoach' instance.
                  @Qualifier("cricketCoach") Coach theAnotherCoach) {		// Second reference also points at the same above 'CricketCoach' instance.
        myCoach = theCoach;
        anotherCoach = theAnotherCoach;
    }
}

• Explicitly Specify Bean Scope
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation. Scope;
import org.springframework.stereotype.Component;

@Component
@Scope (ConfigurableBeanFactory.SCOPE_SINGLETON)				// this is how we can explicitly specify bean scope
public class CricketCoach implements Coach {
    ...
}

• Additional Spring Bean Scopes
Scope		Description
singleton	Create a single shared instance of the bean. Default scope.
prototype	Creates a new bean instance for each container request.
request		Scoped to an HTTP web request. Only used for web apps.
session		Scoped to an HTTP web session. Only used for web apps.
global-session	Scoped to a global HTTP web session. Only used for web apps.


• Prototype Scope Example: a new object instance is created for each injection
// File: CricketCoach.java
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation. Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)		// we have to specify the scope here in 'CricketCoach' class.
public class CricketCoach implements Coach {
    ...
}

// File: DemoController.java
@RestController
public class DemoController {
    // Here we have created two references and both will point at the two different instances.
    private Coach myCoach;
    private Coach anotherCoach;

    @Autowired
    public DemoController(
		  // Here we have done two injections of same class 'CricketCoach', as we have specified 'Prototype' scope, a new object instance is created for each injection
                  @Qualifier("cricketCoach") Coach theCoach,			// first reference will point at one instance of 'CricketCoach'
                  @Qualifier("cricketCoach") Coach theAnotherCoach) {	        // second reference will point at second instance of 'CricketCoach'
        myCoach = theCoach;
        anotherCoach = theAnotherCoach;
    }
}


-- Bean Lifecyle Methods - Overview 

• Bean Lifecycle
Spring Container Started --> beans are instantiated --> dependencies are injected --> internal spring processing occurs --> excutes our custom initialization method
After method gets execute --> Bean is ready to use --> once we use it --> Spring Container gets shutdown --> executes our custom destroy method.																	

• Bean Lifecycle Methods / Hooks
You can add custom code during bean initialization
 Calling custom business logic methods
 Setting up handles to resources (db, sockets, file etc)
You can add custom code during bean destruction
 Calling custom business logic method
 Clean up handles to resources (db, sockets, files etc)

• Initialization of Method configuration
@Component
public class CricketCoach implements Coach {
    public CricketCoach() {
        System.out.println("In constructor: “ + getClass().getSimpleName());
    }

    @PostConstruct	// With the help of this annotation, we have added our own custom initialization code, once the bean has been constructed.
    public void doMyStartupStuff() {
    System.out.println("In doMyStartupStuff(): " + getClass().getSimpleName());
    }

    @PreDestroy		// With the help of this annotation, we have added our own custom cleanup code, which will run just before the bean gets destructed.
    public void doMyCleanupStuff() {
    System.out.println("In doMyStartupStuff(): " + getClass().getSimpleName());
    }
}
 
• Development Process
1. Define your methods for init and destroy
2. Add annotations: @PostConstruct and @PreDestroy


-- Special Note about Prototype Scope - Destroy Lifecycle Method and Lazy Initializ
• Prototype Beans and Destroy Lifecycle
There is a subtle point you need to be aware of with "prototype" scoped beans.
For "prototype" scoped beans, Spring does not call the destroy method. Gasp!

In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, 
and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance.
Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured 
destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that 
the prototype bean(s) are holding.

• Prototype Beans and Lazy Initialization
Prototype beans are lazy by default. There is no need to use the @Lazy annotation for prototype scopes beans.


-- Java Config Bean - Overview

In this is program, we will create a new Class 'SwimCoach' and we will not use any special annotations like '@Component' to configure it as bean.
Instead we will configure it using @Bean annotation.

• Development Process
1. Create @Configuration class
package com. luv2code.springcoredemo.config;
import org.springframework.context.annotation.Configuration;
@configuration								// With this annotation, we are declaring 'SportConfig' a configuration class for configuring spring.
public class SportConfig {
    ...
}

2. Define @Bean method to configure the bean
package com. luv2code.springcoredemo.config;
import com. luv2code.springcoredemo.common.Coach;
import com. luv2code.springcoredemo.common.SwimCoach;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class SportConfig {
    @Bean
    public Coach swimCoach() {		// The bean id defaults to the method name, So this bean will have a bean id of SwimCoach.
        return new SwimCoach();		// returing a new instance of SwimCoach. Here we are manually constructing the object and returning to given caller. 
    }
}

3. Inject the bean into our controller
import com.practice.springcoredemo.common.Coach;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
@RestController
public class DemoController {
    private Coach myCoach;
    @autowired
    public DemoController(@Qualifier("swimCoach") Coach theCoach) {			// here we made use of the bean id 'swimCoach' to inject it.
        System.out.println("In constructor: " + getClass().getSimpleName());
        myCoach = theCoach;
    }
}


• Use case for @Bean
Make an existing third-party class available to Spring framework
You may not have access to the source code of third-party class
However, you would like to use the third-party class as a Spring bean

• Real-World Project Example
Our project used Amazon Web Service (AWS) to store documents
 Amazon Simple Storage Service (Amazon S3)
 Amazon S3 is a cloud-based storage system
 can store PDF documents, images etc
We wanted to use the AWS S3 client as a Spring bean in our app
The AWS S3 client code is part of AWS SDK
 We can’t modify the AWS SDK source code
 We can’t just add @Component
However, we can configure it as a Spring bean using @Bean


------------------------------------------------------------------------------------------- Section 3 ---------------------------------------------------------------------------------------

-- Hibernate / JPA Overview
• What is Hibernate?
A framework for persisting / saving Java objects in a database
Our Java	-->	Hibernate	-->	Database
App		<-- 			<--

• Benefits of Using Hibernate
Hibernate handles all of the low-level SQL
Minimizes the amount of JDBC code you have to develop
Hibernate provides the Object-to-Relational Mapping (ORM)

• What is Object-To-Relational Mapping (ORM)
The developer defines mapping between Java class and database table

Example:
Java Class		-->	HIBERNATE		-->	Database Table
Student			<--	(Middleware)		<--	Student
id: int								id INT
firstName: String						first_name VARCHAR(45)
lastName: String						last_name VARCHAR(45)
email: String							email VARCHAR(45)

As you can see in above example, On the far left side we have our Java Class 'Student'. On the far right side, we have our Database Table 'Student'.
Now the Hibernate works as a Middleware, It will set a one-to-one mapping between the fields of our java class and the actual columns in database.
We can set up this mapping via configuration file via XML or through Java Annotations.

• What is JPA?
JPA stands for Jakarta Persistence API(JPA), previously known as Java Persistence API.
It is a standard API for Object-to-Relational-Mapping (ORM)
It is only a specification which defines a set of interfaces and requires an implementation to be useable.

• JPA - Vendor Implementations
One of the most popular implementations for JPA is 'Hibernate'.
Just like Java Coding, It take those interfaces and it provides an implementation of those given interfaces.

• Benefits of Using JPA
By having a standard API, you are not locked to vendor's implementation
Maintain portable, flexible code by coding to JPA spec (interfaces)
Can theoretically switch vendor implementations
 For example, if Vendor ABC stops supporting their product
 You could switch to Vendor XYZ without vendor lock in

• Example for JPA - Vendor Implementations
Suppose, we have an application 'MyBizApp' and we are writing our DAO code based on the JPA spec.
Now in one version of our project, we are using 'EclipseLink' as our vendor implementation, and in second version of our project, we want to 
change our vendor implementation to 'Hibernate'. Now this swapping of JPA Vendor Application is easily possible. We only will have to make 
minimal code changes as we are writing code to the standard specification. That is we simply have to tell our configuration to which vendor 
to use.   
 
• Saving a Java Object with JPA
Student theStudent = new Student("aum", "soni", “aumsoni2002@gmail.com");	// create Java object
entityManager.persist (theStudent);						// save it to database, 'entityManager' is a special JPA helper object.
With above lines of code, the data will get stored in the database.

• Retrieving a Java Object with JPA
Student theStudent = new Student("aum", "soni", “aumsoni2002@gmail.com");	// create Java object
entityManager.persist (theStudent);						// save it to database, 'entityManager' is a special JPA helper object.

// the database will automatically give our first object the id '1'. And with the help of that id, we can retrieve that object from database. 
int theId = 1;									// now retrieve from database using the primary key
Student myStudent = entityManager.find(Student.class, theId);			// 1st Parameter: NameOfTable.class, 2nd Parameter: id in integer to find a particular object.

• Querying for Java Objects
Let us retrieve/Query all students object from the 'Student' database table

TypedQuery<Student> theQuery = entityManager.createQuery("from Student", Student.class); // here we are saving a list of all student objects into 'theQuery'.
List<Student> students= theQuery.getResultList();					 // Now to retrieve all those objects, we have to make use of 'getResultList()'.


-- Hibernate, JPA and JDBC
• How does Hibernate/JPA relate to JDBC?
Hibernate/JPA uses JDBC in the background for all database communications
Hibernate/JPA is just an another layer of abstraction on top of JDBC.
So when our application uses the Hibernate/JPA framework, our app will actually store and retrieve the objects using the JPA API.
Hibernate/JPA does a lot of the low-level work for you, but in the background, it all goes through the standard JDBC API.


-- Setting up Development Enviornment
• MySQL Database
In this learning, we will use the MySQL Database
MySQL includes two components 
 MySQL Database Server
 MySQL Workbench

• MySQL Database Server
The MySQL Database Server is the main engine of the database
Stores data for the database
Supports CRUD features on the data

• MySQL Workbench
MySQL Workbench is a client GUI for interacting with the database
Create database schemas and tables
Execute SQL queries to retrieve data
Perform insert, updates and deletes on data
Handle administrative functions such as creating users

• Setting up Database Table - Overview
For this learning/project, we will be using two database scripts:
File: 01-create-user.sql
This file creates a new MySQL user for our application with user-id: springstudent and password: springstudent

File: 02-student-tracker.sql
This file creates a new database table: student
And four fields in it: id, first_name, last_name and email


-- Setting Up Database Table - Coding
Steps:
1. Open MySQL Workbench
2. Open the 'root' MySQL Connections which you created while doing installation process.
3. Goto: File --> Open SQL Script --> open '01-create-user.sql'
4. Now to create a new user: Run the above opened sql file by clicking on the golden thunder sign on workbench.
5. We have successfully created a new user. 
6. Now we have to create a new user for that newly created user.
7. Goto: Home Page --> Click on plus button which is right after 'MySQL Connections' --> Enter 'Connection name' and 'username' 
8. --> Click 'Test Connection' --> Enter password --> Click ok 
9. Now we have created a new connection.
10. Goto: Open 'springstudent' connection --> File --> Open SQL Script --> open '02-student-tracker.sql'
11. Now to create a new schemas: Run the above opened sql file by clicking on the golden thunder sign on workbench.
12. Goto: Schemas --> Refresh --> You will find 'student_tracker'


-- Setting Up Spring Boot Project - Overview

• Automatic Data Source Configuration
In Spring Boot, Hibernate is the default implementation of JPA
EntityManager is main component for creating queries etc
EntityManager is from Jakarta Persistence API (JPA)
Based on configs, Spring Boot will automatically create the beans: DataSource, EntityManager, ...
We can then inject these into our app, for example our DAO

• Setting up Project with Spring Initialzr
At Spring Initializr website, start.spring.io
Add dependencies
 MySQL Driver: mysql-connector-j
 Spring Data JPA: spring-boot-starter-data-jpa

• Spring Boot - Auto configuration
Spring Boot will automatically configure our data source for us.
Based on entries from Maven pom file
 JDBC Driver: mysql-connector-j
 Spring Data (ORM): spring-boot-starter-data-jpa
Spring boot reads DB connection info from application .properties

File: application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/student_tracker
spring.datasource.username=springstudent
spring.datasource.password=springstudent

No need to give JDBC driver class name Spring Boot will automatically detect it based on URL.

• Creating Spring Boot - Command Line App
We will create a Spring Boot - Command Line App
This will allow us to focus on Hibernate / JPA
Later in the learning, we will apply this to a CRUD REST API

Example:
import org. springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot. autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
@SpringBootApplication
public class Cruddemoapplication {
    public static void main(String[] args) {
        SpringApplication.run(CruddemoApplication.class, args);
    }

   @Bean
   public CommandLineRunner commandlineRunner(String[] args) {
       return runner -> {
          System.out.println("Hello world");
       }; 
   }
}

This above CommandLineRunner is from the Spring framework, which is basically  a hook that allows us to execute code
after the Spring Beans have been loaded into the application context.
Inside it, we have a return statement 'runner' which is a Lambda Expression where we can basically add our custom code to interact with the database.

 
-- Setting Up Spring Boot Project - Coding - Part 1
-- Setting Up Spring Boot Project - Coding - Part 2
• Example for how to setup project for making use of Hibernate/JPA for crud operations
  Project: 01-cruddemo-student


-- JPA Annotations - Overview

• JPA Dev Process - To Do List
1. Annotate Java Class
2. Develop Java Code to perform database operations

• Terminology
Entity Class: It is just a Java Class that is mapped to a database table.

• Object-To-Relational Mapping (ORM)
We have our Java class called 'Student' that has four fields, id, firstName, lastName, and email, we'll make use of JPA, 
and we'll map it to a given database table called 'Student' that has four columns, id, first_name, last_name, and email.
So we need to kind of provide mappings between the two.

As we know, Hibernate is the default JPA implementation in Spring Boot.
Example:
Java Class		-->	HIBERNATE/JPA		-->	Database Table
Student			<--	(Middleware)		<--	Student
id: int								id INT
firstName: String						first_name VARCHAR(45)
lastName: String						last_name VARCHAR(45)
email: String							email VARCHAR(45)

• Entity Class
At a minimum, the Entity class: 
Must be annotated with @Entity
Must have a public or protected no-argument constructor. The class can also have other constructors.

• Java Annotations
Step 1: Map class to database table
@Entity					// here we are declaring our 'Student' java class as an Entity Class. 
@Table(name="student")			// here we are mapping our java class to the database table 'student'. (name="tableName")
public class Student{
    ...
}

Step 2: Map fields to database columns
@Entity
@Table(name="student")
public class Student{
    @id
    @Column(name="id")			// here we are mapping our 'id' field of java class to the 'id' column of the Database table.
    private int id;

    @Column(name="first_name")		// here we are mapping our 'firstName' field of java class to the 'first_name' column of the Database table.
    private String firstName;
}

• @Column and @Table - Optional
the use of @Column is optional.
If you do not want to specify @Column then the column name must be same name as Java field.
Same goes with the @Table too. 	

• Terminology
Primary Key: Uniquely identifies each row in a table. Must be a unique value. Cannot contain NULL values

• MySQL - Auto Increment
In the MySQL database, we can make use of an auto increment. We can define our primary key, and then we can specify that it's an auto increment.
So In below code, we have a little snippet here, create table student.
We have this column id which of type int, we delcare here that it will never be null, and then we specify auto increment.
Behind the scenes, MySQL will keep track by automatically incrementing this id, and making sure it's a unique value.
We also specify that our given column id is the primary key for this given table.
MySQL Code:
CREATE TABLE student (
  id int NOT NULL AUTO_INCREMENT,			// here we are declaring that id cannot be null and we specify auto increment on it.
  first_name varchar(45) DEFAULT NULL,
  last_name varchar(45) DEFAULT NULL,
  email varchar(45) DEFAULT NULL,
  PRIMARY KEY (id)					// here we are declaring our 'id' column as the primary key of this table.
}

• JPA Identity - Primary Key
Once we specify auto increment into our database table, we also need to declare it into our Java Code with @Id annotation
@Entity
@Table(name="student")
public class Student{
    @Id							// here we are declaring our 'id' field as the Unique Identifier of this Entity Class
    @GeneratedValue(strategy=GenerationType.IDENTITY)	// here what we are saying is that this id value will be generated by the database and managed by the database. 
							// There's no need for our code to manually try and keep track of that given id.
    @Column(name="id")					// here we are mapping our 'id' field of java class to the 'id' column of the Database table.
    private int id;
}

• ID Generation Strategies
Name				Description
GenerationType.AUTO		Pick an appropriate strategy for the particular database
GenerationType.IDENTITY		Assign primary keys using database identity column
GenerationType.SEQUENCE		Assign primary keys using a database sequence
GenerationType.TABLE		Assign primary keys using an underlying database table to ensure uniqueness

• Custom generation strategy
We can define your own CUSTOM generation strategy :-)
Create implementation of org. hibernate.id.IdentifierGenerator
Override the method: public Serializable generate(...)


-- JPA Annotations - Coding
• Example for how to create an Entity Class, Map that class to database table and map class's fields to database table's columns
  Project: 01-cruddemo-student-create


-- Saving a Java Object with JPA - Overview
• Sample App Features
For this project, we will be doing CRUD operation on student object.
Create a new Student
Read a Student
Update a Student
Delete a Student


• Student Data Access Object
The Data Access object(DAO) is responsible for interacting with the database.
cruddemo App	<--->	Student DAO	<--->	database

Our DAO needs a JPA Entity Manager
JPA Entity Manager is the main component for saving / retrieving entities
Student DAO	Entity Manager	<--->	data source	<--->	database

• DAO Methods
save(...)
findById(...)
findAll()
findByLastName(...)
update(...)
delete(...)
deleteAll()

• JPA Entity Manager
Now as far as the other supporting components, our JPA entity manager needs a data source.
So the data source basically defines the database connection information and the JPA entity manager and the data source
are automatically created by Spring Boot, based on information from our native pom file, and also information from our application properties
such as the URL, user ID, and password. It'll actually connect to the database. And then we can auto wire or inject the JPA entity manager into our student DAO.	

• @Transactional Annotation
The @Transactional annotation in JPA (Java Persistence API) is used to define the transactional boundaries for a method or a class. 
When this annotation is applied to a method, it indicates that a transaction will be initiated before the method is executed and 
committed or rolled back after the method completes. When applied to a class, it applies to all the public methods of the class. 
This annotation is used to manage transactions in JPA and ensures that the database is kept in a consistent state in case of any 
errors during the execution of the method.

• @Repository Annotation
This annotation is a sub-annotation of @Component annotation.
So this annotation is applied to DAO implementations and Spring will automatically register the DAO implementation, thanks to component scanning.
And then Spring will provide translation of any JDBC related exceptions.
So here when we say translation, meaning that if we have any checked JDBC exceptions and then Spring will translate these two unchecked
exceptions basically it makes the coding a bit easier here for interfacing with a given database.

• Student DAO:		Student DAO	Entity Manager	<--->	data source	<--->	database
Steps:
1. Define DAO interface
import com.practice.cruddemo.entity.Student;
public interface StudentDAO {				// Creating an Interface by the name 'StudentDAO'. 
    void save(Student theStudent);			// defining a method 'save' which takes an object of type 'Student' as an argument.
}

2. Define DAO implementation. Than Inject the entity manager
import com.practice.cruddemo.entity.Student;
import jakarta.persistence.EntityManager;
import org.springframework.beans.factory.annotation.Autowired;

@Repository
public class StudentDAOImpl implements StudentDAO {	// creating a class 'StudentDAOImpl' which implements 'StudentDAO' interface to use the method 'save'.
    private EntityManager entityManager;		// creating a field 'entityManager' of type 'EntityManager' which will be assigned an instance of type 'EntityManager' through constructor 

    @Autowired
    public StudentDAOImpl(EntityManager theEntityManager) {	// here we have created a constructor which take an object(instance) of type 'EntityManager' as an argument
        entityManager = theEntityManager;		// here we are saving the coming new instance to the field 'entityManager'
    }
    
    @Override
    @Transactional					// when a method does create, update or delete within the database through a method, That method should have this annotation
    public void save(Student theStudent){		
	entityManager.persist(theStudent);    		// here we are overriding the 'save' method with saving the new Student object into our database table.
    }
}
 
3. Update main app
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class CruddemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(CruddemoApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandlineRunner(StudentDAO studentDAO) { // here we are injecting an object 'studentDAO' of type 'StudentDAO' to use this interface's methods
        return runner -> {
            createStudent(studentDAO);		// here we are sending the same object to the method 'createStudent' as an argument. 
        };
    }
	
    private void createStudent(StudentDAO studentDAO){
       // create the student object
       System.out.println("Creating new student object...");
       Student newStudent = new Student("aum", "soni", "aumsoni2002@gmail.com");

       // save the student object
       System.out.println("Saving student object...");
       studentDAO.save(newStudent);

       // display id of the saved student
       System.out.println("The student is saved. The generated ID is: " + newStudent.getId()); 
    }
}


-- Saving a Java Object with JPA - Coding - Part 1
-- Saving a Java Object with JPA - Coding - Part 2
• Example for how to create a new student object into our MySQL Database table
  Project: 01-cruddemo-student-create


-- Changing Index of MySQL Auto Increment
• Changing the start index value of 'id' to 3000 in our database table
Workbench: SQL File
ALTER TABLE student_tracker.student AUTO_INCREMENT=3000;

• Reset the AUTO_INCREMENT value to 1
Workbench: SQL File
TRUNCATE student_tracker.student		// The 'TRUNCATE' will remove all data from the database table and reset AUTO_INCREMENT to start with 1.



-- Reading Objects with JPA - Overview
• Read/Retrieve
// retrieve/read from database using the primary key
// in this example, retrieve Student with primary key: 1
Student myStudent = entityManager.find(Student.class, 1);

• Development Process
1. Add new method to DAO interface
import com.practice.cruddemo.entity.Student;
public interface StudentDAO {
    ...
    Student findById(Integer id);	// defining a method 'findById' which takes 'id' of type 'Integer' as an argument and returns an object of type student
}

2. Add new method to DAO implementation
@Repository
public class StudentDAOImpl implements StudentDAO {
    private EntityManager entityManager;

    // inject entity manager using constructor injection
    @Autowired
    public StudentDAOImpl(EntityManager theEntityManager) {    
        entityManager = theEntityManager;        
    }

    @Override
    @Transactional                    
    public void save(Student theStudent) {
        entityManager.persist(theStudent);  
    }
 
    @override
    public Student findById(Integer id){		// here we are creating a method 'findById' that will take 'id' of type Integer as an argument.
    	return entityManager.find(Student.class, id);	// here we will send the above 'id' and the 'Student' class as argument to find the data which has the same id. 
    }
}

3. Update main app
public class CruddemoApplication {

    ...

    private void readStudent(StudentDAO studentDAO) {
        // create the student object
        System.out.println("Creating new student object...");
        Student secondStudent = new Student("shivang", "soni", "shivangsoni1998@gmail.com");

        // save the student object
        System.out.println("Saving student object...");
        studentDAO.save(secondStudent);

        // display id of the saved student
        System.out.println("The student is saved. The generated ID is: " + secondStudent.getId());

        // Now that a new student will get created with above steps lets retrieve that student and print it in terminal

        // Retrieve student based on its id
        System.out.println("Retrieving student with id: " + secondStudent.getId());

        // here we are calling the 'findById' method of 'StudentDAO' interface which will find the student object from database table and return it
        Student readSecondStudent = studentDAO.findById(secondStudent.getId());

        // Printing the returned student Object
        System.out.println("Found the student: " + readSecondStudent);
    }
}


-- Reading Objects with JPA - Coding
• Example for how to read a single student from the MySQL database table
  Project: 02-cruddemo-student-read


-- Querying Objects with JPA - Overview
• JPA Query Language(JPQL)
JPA has the JPA query language or JPQL. It's a query language for retrieving objects. It's similar in concept to SQL,
where you can select from a given table and grab some data accordingly.
You can also make use of constraints/selectors like 'where', 'like'. You can order the data, join, so and so forth.
However, the difference here is that JPQL is based on the entity name and entity fields as opposed to the direct 
table names and table columns. So when you use JPQL, by default, you make use of the entity name and entity fields.

• Retrieving all Students
In below code, the 'Student' in 'FROM Student' is our Entity Class which we created into our entity package. It is not the name of our database table
We have to use the Entity name here because all JPQL syntax is based on entity name and entity fields
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class);
List<Student> students = theQuery.getResultList(); 

• Retrieving Students where lastName='aum'
As all JPQL syntax is based on entity name and entity fields, In below code we made use of 'lastName' entity field
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student WHERE lastName='soni'", Student.class);
List<Student> students = theQuery.getResultList();

• Retrieving Students using 'OR'
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student WHERE lastName='soni' OR firstName='aum'", Student.class);
List<Student> students = theQuery.getResultList();

• Retrieving Students using 'LIKE'
// Match email address that ends with '@gmail.com'
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student WHERE email LIKE '%@gmail.com'", Student.class);
List<Student> students = theQuery.getResultList();

• JPQL Named Parameters
public List<Student> findByLastName(String theLastName) { // here we are creating a method 'firdByLastName' which takes 'theLastName' of type String as an argument
    // Now in below code, we are just getting a student with its lastName but we are using ':theData' which gets swap with the comming 'lastName'.  
     TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student WHERE lastName=:theData", Student.class); 
    theQuery.setParameter("theData", theLastName) ; // The swapping part is done here with this syntax.
    return theQuery.getResultList();	// here we are just returing the list.
}

• Development Process
1. Add new method to DAO interface
public interface StudentDAO {               
    ...
    List<Student> findAll();	// here we are creating method 'findAll' which will return list of students
}

2. Add new method to DAO implementation
@Repository
public class StudentDAOImpl implements StudentDAO {
    private EntityManager entityManager;

    // inject entity manager using constructor injection
    @Autowired
    public StudentDAOImpl(EntityManager theEntityManager) {    
        entityManager = theEntityManager;        
    }

    @Override
    @Transactional                    
    public void save(Student theStudent) {
        entityManager.persist(theStudent);  
    }
 
    @Override
    public Student findById(Integer id){		
    	return entityManager.find(Student.class, id);
    }

    @Override
    public List<Student>findAll(){
	TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class); // retrieving all student objects from the database table
        return theQuery.getResultList(); 							 // returning the list of all student objects
    }
}

3. Update main app
@SpringBootApplication
public class CruddemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(CruddemoApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandlineRunner(StudentDAO studentDAO) { // here we are injecting an object 'studentDAO' of type 'StudentDAO' to use this interface's methods
        return runner -> {
            queryAllStudents(studentDAO);
        };
    }

    private void queryAllStudents(StudentDAO studentDAO) {
        // here we are calling 'findAll' method of 'StudentDAO' interface which will find the all student objects from database table and return it
        List<Student> allStudents = studentDAO.findAll();

        // Printing all student objects through enhanced for loop
        for (Student eachStudent : allStudents) {
            System.out.println(eachStudent);
        }
    }
}


-- Querying Objects with JPA - Coding - Part 1
• Example for how to query all student objects
Project: 03-cruddemo-student-query-findAll


-- Querying Objects with JPA - Coding - Part 2
• Example for how to query a student by its last name
Project: 03-cruddemo-student-query-findByLastName


-- Updating Objects with JPA - Overview
• Update a Student
Student theStudent = entityManager.find(Student.class, 1);	// first we find the student object through its 'id'
myStudent.setFirstName( "amit" ); 				// Second, we change first name to "amit"
entityManager.merge(theStudent); 				// Lastly, we update the student object's first_name which has id=1 in our database table.

• Update the last name for all students
In below code, we are updating all student object's last name to 'Tester'. The total number of updated rows will be saved in 'numOfRowsUpdated'
int numOfRowsUpdated = entityManager.createQuery (“UPDATE Student SET lastName='Tester'”).executeUpdate();

• Development Process
1. Add new method to DAO interface
public interface StudentDAO {               
    ...
    void update(Student theStudent)	// here we are creating method 'update' which will take an object 'theStudent' of type 'Student'.
}

2. Add new method to DAO implementation
@Repository
public class StudentDAOImpl implements StudentDAO {
    private EntityManager entityManager;

    // inject entity manager using constructor injection
    @Autowired
    public StudentDAOImpl(EntityManager theEntityManager) {    
        entityManager = theEntityManager;        
    }

    @Override
    @Transactional				// when a method does create, update or delete within the database through a method, That method should have this annotation
    public void update(Student theStudent){
	entityManager.merge(theStudent);
    }
}

3. Update main app
@SpringBootApplication
public class CruddemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(CruddemoApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandlineRunner(StudentDAO studentDAO) { // here we are injecting an object 'studentDAO' of type 'StudentDAO' to use this interface's methods
        return runner -> {
            updateStudent(studentDAO);
        };
    }

    private void updateStudent(StudentDAO studentDAO) {
        int studentId = 1;
	System.out.println("Getting student with id: " + studentId);
	Student toBeUpdatedStudent = studentDAO.findById(studentId);	// finding a student object with id equals to 1.
        System.out.println("Getting student with id: " + studentId);

        System.out.println("Updating student...");
        myStudent.setFirstName("amit");					// change first name to "amit"
        studentDAO.update(toBeUpdatedStudent);				// updating new changes into our database.
       
        System.out.println("Updated student: + toBeUpdatedStudent);	// display updated student
    }
}



-- Deleting Objects with JPA - Overview
• Delete a Student
int id = 1;
Student theStudent = entityManager.find(Student.class, id);	// first we find the student object through its 'id'
entityManager.remove (theStudent);				// Lastly, we remove that student object from our database table.

• Delete based on a condition
// here we are deleting all those student objects which have 'soni' as their last name. And it will save total number of deleted rows in 'numRowsDeleted'
int numRowsDeleted = entityManager.createQuery("DELETE FROM Student WHERE lastName='soni'").executeUpdate();

• Delete All Students
int numRowsDeleted = entityManager.createQuery("DELETE FROM Student").executeUpdate();

• Development Process
1. Add new method to DAO interface
public interface StudentDAO {               
    ...
    void delete(Integer id)	// here we are creating method 'delete' which will take 'id' of type 'Integer' as an argument.
}

2. Add new method to DAO implementation
@Repository
public class StudentDAOImpl implements StudentDAO {
    private EntityManager entityManager;

    // inject entity manager using constructor injection
    @Autowired
    public StudentDAOImpl(EntityManager theEntityManager) {    
        entityManager = theEntityManager;        
    }

    @Override
    @Transactional				// when a method does create, update or delete within the database through a method, That method should have this annotation
    public void delete(Integer id){
	Student theStudent = entityManager.find(Student.class, id);
	entityManager.remove(theStudent);
    }
}

3. Update main app
@SpringBootApplication
public class CruddemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(CruddemoApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandlineRunner(StudentDAO studentDAO) { // here we are injecting an object 'studentDAO' of type 'StudentDAO' to use this interface's methods
        return runner -> {
            deleteStudent(studentDAO);
        };
    }

    private void deleteStudent(StudentDAO studentDAO) {
        int studentId = 1;
	System.out.println("deleting student with id: " + studentId);
	studentDAO.delete(studentId);   
    }
}


-- Create Database Tables from Java Code - Overview
• Create database tables: student
JPA / Hibernate provides an option to auto-magically create database tables. It creates tables based on Java code with JPA/ Hibernate annotations
and it is useful for development and testing.
We have our Java code with the annotations, we run it through this Hibernate tool, and then it'll actually generate the SQL
and also execute that SQL. Then it applies that on the given database. So there's no need for us to write any of the SQL.
Java code	-->	JPA/Hibernate	-->	SQL	-->	Database

• Configuration
In the Hibernate configuration file, we will set up a property as shown below and we give a property value.
Here we'll call it create. So when we run our application, Hibernate will drop the tables and then create them again from scratch.
And this is all based on the JPA/Hibernate annotations that are in our Java code.
In Spring Boot configuration file: application.properties
spring.jpa.hibernate.ddl-auto=create

• Creating Table based on Java Code
In our 'Student' class, we have put '@Table' with table name to let Spring Boot know that this class is what going to be mapped with the database table 'student'.
We also have put '@Columns' for all fields that we consider them as column in database table.
Now If the 'student' table in our database does not exist, what JPA/Hibernate tool will do is, it will create a sql query based on annotations we used and execute that
query to create a table with same table name and columns with same field names in the database. 

• Configuration - application.properties
spring.jpa.hibernate.ddl-auto=PROPERTY-VALUE
Property Value 		Property Description
none 			No action will be performed
create-only 		Database tables are only created
drop 			Database tables are dropped
create 			Database tables are dropped followed by database tables creation
create-drop 		Database tables are dropped followed by database tables creation. On application shutdown, drop the database tables
validate 		Validate the database tables schema
update 			Update the database tables schema

• Use Case of using: spring.jpa.hibernate.ddl-auto=create
Automatic table generation is useful for
 Database integration testing with in-memory databases
 Basic, small hobby projects 


-- Create Database Tables from Java Code - Coding - Part 1
-- Create Database Tables from Java Code - Coding - Part 2
• Example for how to create database table by only making use of Java Code and zero use of sql queries
Project: 08-cruddemo-create-db-tables-automatically










